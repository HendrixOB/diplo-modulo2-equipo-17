---
title: "Proyecto final módulo 2"
author: "Equipo - 17"
output: html_document
---

# Integrantes:

+ Hendrix Roberto Olvera Barbecho Rol: Administrador
+ Erick Muñiz Morales. Rol: Colaborador 1
+ Francisco Eduardo Díaz Barrios. Rol: Colaborador 2

```{r}
library(DBI)
library(dbplyr)
library(RSQLite)
library(visdat)
library(ggplot2)
library(readr)
library(quanteda)
library(quanteda.textplots)
library(tidyr)
library(stringr)
library(lubridate)
library(stringi)
library(reticulate)
library(skimr)
library(naniar)
library(dplyr)
conn <- DBI::dbConnect(RSQLite::SQLite(), "vuelos.db")
```

# Parte 1

### Intrucciones colaborador 1 

Desde su máquina crear chunks de código R en el archivo "proyecto_final.Rmd" (que obtuvo del Administrador) que muestre el número de tablas y sus nombres de la base de datos "vuelos"; además, crear un objeto en R, un por cada tabla de la base de datos. Hacer commit y push del código al repositorio del administrador y hacer un pull request.

```{r}
tablas <- dbListTables(conn) 

numero_tablas <- length(tablas)

cat(numero_tablas)
cat("\n")
cat(tablas)
```

Tenemos 5 tablas. 

```{r}
aerol <- dbGetQuery(conn, "SELECT * FROM aerolineas")
aerop <- dbGetQuery(conn, "SELECT * FROM aeropuertos")
avio <- dbGetQuery(conn, "SELECT * FROM aviones")
clim <- dbGetQuery(conn, "SELECT * FROM clima")
vuelo <- dbGetQuery(conn, "SELECT * FROM vuelos")
```

### Instrucciones Colaborador 2: 

Desde su máquina crear chunks de código R en el archivo "proyecto_final.Rmd" (que obtuvo del Administrador) que use las funciones vis_dat() y vis_miss() de la librería {visdat} para analizar los tipos de datos y datos faltantes de cada una de las tablas generadas por el Colaborador 1. Debe corregir la línea author: "Equipo - n" con el número correcto de equipo y agregar los nombres completos de los integrantes en la sección de # Integrantes. Hacer commit y push del código al repositorio del administrador y hacer un pull request.
 
```{r}
aerol %>% vis_dat()
aerop %>% vis_dat()
avio %>% vis_dat()
clim %>% vis_dat()
```

La tabla "vuelo" es muy larga por lo que no se puede visualizar completa usando vis_dat() o vis_miss() por lo que vamos a tomar subconjuntos de la tabla
Los subconjuntos tienen 10 mil elementos y serán tomados los primeros  y los últimos (head y tail respectivamente), los que tengan mayor distancia de vuelo y 
un subconjunto aletorio.

```{r}
vuelo %>%  dplyr::slice_head( n = 10000 ) %>% vis_dat()
vuelo %>%  dplyr::slice_tail(n = 10000) %>% vis_dat()
vuelo %>%  dplyr::slice_max(distance, n = 10000) %>% vis_dat( )
vuelo %>%  dplyr::slice_min(distance, n = 10000) %>% vis_dat()
vuelo %>%  dplyr::slice_sample(n = 10000) %>% vis_dat()
```

```{r}
aerol %>% vis_miss()
aerop %>% vis_miss()
avio %>% vis_miss()
clim %>% vis_miss()
```

```{r}
vuelo %>%  dplyr::slice_head( n = 10000 ) %>% vis_miss()
vuelo %>%  dplyr::slice_tail(n = 10000) %>% vis_miss()
vuelo %>%  dplyr::slice_max(distance, n= 10000) %>% vis_miss()
vuelo %>%  dplyr::slice_min(distance, n= 10000) %>% vis_miss()
vuelo %>%  dplyr::slice_sample(n=10000) %>% vis_miss()
```

### Intrucciones Admi

Administrador del equipo. Desde su máquina crear chunks de código R en el archivo "proyecto_final.Rmd" (que obtuvo del Administrador) que use funciones de la librería {skimr} para obtener un resumen del tipo de variables, resumen de variables numéricas y resumen de variables categóricas para cada uno de los datasets que creo el Colaborador 1. Hacer commit y push del código al repositorio del administrador y revisar los pull requests de los colaboradores 1 y 2.

```{r}
aerol %>% skim()
aerol %>%
  skim() %>%
  yank("numeric")
aerol %>%
  skim() %>%
  yank("character")
```

```{r}
aerop %>% skim()
aerop %>%
  skim() %>%
  yank("numeric")
aerop %>%
  skim() %>%
  yank("character")
```

```{r}
avio %>% skim()
avio %>%
  skim() %>%
  yank("numeric")
avio %>%
  skim() %>%
  yank("character")
```

```{r}
clim %>% skim()
clim %>%
  skim() %>%
  yank("numeric")
clim %>%
  skim() %>%
  yank("character")
```

```{r}
vuelo %>% skim()
vuelo %>%
  skim() %>%
  yank("numeric")
vuelo %>%
  skim() %>%
  yank("character")
vuelo %>%
  skim() %>%
  yank("character")
```

### Comentario Colaborador 2:

#### Subconjunto 1: Aerol

El subconjunto tiene pocos datos y ninguna perdida de información en esta tabla. El análisis numérico no nos permite obtener mucha información y esto se debe a que esta tabla contiene únicamente variables son categoricas. El  nombre más largo tiene 27 caracteres, el más corto solo 9 caracteres y todas las abreviaturas son de un mismo largo lo cual nos indica que esto es consistente con ser  únicas. 

#### Subconjunto 2: Aerop

Se puede observar que se tienen variables tanto categóricas como numéricas que nos permiten hacer ambos analisis y diferenciar a las columnas que a pesar de tener nombres similares (tz y timezone) se pude observar del análisis que son diferentes puesto que tz refiere a una variable númerica y timezone a una categórica, en esta última hay una ligera perdida de información del nombre de la zona con ese huso horario pero esto podría relacionarse (deducirse) con la variable númerica correspondiente.  Las variables númericas nos dan información sobre donde se encuentran los aeropuertos y el análisis nos permite observar de que parte estan concentrados la mayor cantidad de aeropuertos en nuestros datos. 
Además de las variables categoricas se puede notar que los nombres de los aeropuertos no son únicos aunque deben ser aeropuertos diferentes pues tienen abreviaturas diferentes (únicas) y 9 zonas horarias en nuestros datos.

#### Subconjunto 3: Avio

No hay datos de tipo categorico faltantes, además este análisis nos hace notar que el número de cola para cada avión es único, que en solo tenemos 3 tipos diferentes de aviones, 6 tipos de motores, 127 modelos y 35 fabricantes. En las variables númericas la velocidad del avión es una "variable" con el 99%  de datos faltantes. La mayoría de los aviones fueron fabricados alrededor del año 2000, tiene 2 motores y tenemos aviones en nuestros datos que van de los 2 a los 450 asientos. 


#### Subconjunto 5: Clim

Este subconjunto solo tiene 1 variable categórica que no aporta demasiada información. Por otro lado, las variables númericas nos dan mucha información acerca de cuales son las condiciones climaticas más favorables para efectuar un vuelo en la zona del mundo de nuestros datos. En particular la variable que contiene observaciones de las rafagas del viento tiene muy pocos datos. La mayor cantidad de datos en este subconjunto son del año 2013, la temperatura de la mayoría de los vuelos no es caliente (y además la temperatura no esta dada en grados Celsius), los vuelos se dan en condiciones donde no hay precipitación (lluvia) en su amplia mayoría, al menos la mitad de los vuelos se efectuan con menos de 61.7% de humedad relativa.


#### Subconjunto 5: Vuelo

Como el subconjunto tiene demasiados datos puede que este tipo de visualizaciones sea inadecuada para conocer los datos. De las variables categoricas observamos que se repiten variables de subconjuntos pasados que nos sirven para identificar los vuelos, pero existen varios (2512) vuelos donde no se registro el número de cola del avión, por otro lado las aerolíneas son una variable que guarda sentido con lo visto en el subconjunto 1 respetando su únicidad. En el caso de las variables numéricas, por lo general los vuelos son de 93.6 minutos, los vuelos no rebasan las 685 minutos de vuelo (tiempo en aire). Los vuelos en su mayoria recorren 1040 millas y de la misma manera que en el subconjunto 4 la mayoría de los datos son del año 2013.

# Segunda parte

## Subsección 1: Vuelos de NYC
Utilizaremos las tablas de la base de datos vuelos.db que incluye información de:

- flights: Detalles de todos los vuelos que salieron de NYC (JFK, LGA, EWR) en 2013.
- airlines: Códigos y nombres de aerolíneas.
- airports: Información sobre aeropuertos, incluyendo ubicación.
- planes: Datos sobre aeronaves, incluyendo año de fabricación.
- weather: Datos meteorológicos por hora para los aeropuertos de NYC.

Para facilitar las cosas guardo las bases combinadas todas juntas

```{r}
datos_conj <- dbGetQuery(conn, "SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp,
           humid, wind_dir, wind_speed, wind_gust, precip, pressure, visib
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)")
```

## 1.¿Qué aerolínea tuvo el mayor retraso promedio en la salida en 2013?

Frontier Airlines Inc. Tomamos depdelay para el tiempo de retraso de salida.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.faa aeropuerto_origen, A.dest, C2.faa aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           SELECT aerolinea Aerolinea, AVG(dep_delay) retraso_prom
           FROM BASE
           GROUP BY 1
           ORDER BY 2 DESC LIMIT 1")
```

```{r}
datos_conj %>%  dplyr::group_by(aerolinea) %>% 
  dplyr::summarise(incidentes_tot = mean(dep_delay, na.rm = TRUE)) %>%
  dplyr::slice_max(n = 1, order_by = incidentes_tot, with_ties = TRUE)
```

## 2.¿Qué día de la semana tuvo más vuelos retrasados en promedio?

El jueves por promedio tiene mas tiempo de atraso. Los lunes son los días con mas vuelos atrasados.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.faa aeropuerto_origen, A.dest, C2.faa aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)),
    
           FINAL AS (SELECT *, datetime(time_hour, 'auto','localtime', '+1 hour') fecha,
           strftime('%w', datetime(time_hour, 'auto','localtime' )) dia_semana, 
           CASE WHEN dep_delay > 0 OR arr_delay > 0 THEN 1 ELSE 0 END retraso_total,
           CASE WHEN dep_delay <> 0 OR arr_delay <> 0 THEN 1 ELSE 0 END retraso_positivo
           FROM BASE
           ORDER BY day)
           
           SELECT dia_semana, sum(retraso_total), sum(retraso_positivo),
           AVG(dep_delay), count(dep_delay)
           FROM FINAL
           GROUP BY 1
           ORDER BY 4 DESC")
```

```{r}
datos_conj <- datos_conj %>% dplyr::mutate(departure_time = lubridate::make_date(year,month,day),
                                   weekday = wday(departure_time, label = TRUE, abbr = FALSE),
                                   atrasos_salida = dplyr::case_when(dep_delay != 0 ~ 1,
                                                                TRUE ~ 0),
                                   atrasos_llegada = dplyr::case_when(arr_delay != 0 ~ 1,
                                                                TRUE ~ 0),
                                   atrasos_total = dplyr::case_when(dep_delay != 0 | arr_delay != 0 ~ 1,
                                                                TRUE ~ 0),
                                   )

datos_conj %>%  dplyr::group_by(weekday) %>% 
  dplyr::summarise(incidentes_tot = mean(dep_delay, na.rm = TRUE),
                   atrasos_salida = sum(atrasos_salida),
                   atrasos_llegada = sum(atrasos_llegada),
                   atrasos_total = sum(atrasos_total)) %>% 
  dplyr::arrange(desc(atrasos_total))
```

## 3.¿Cuál es la distribución de los retrasos en la salida para cada aeropuerto?

Tomando la distribución como el valor absoluto de la diferencia entre el tiempo programado y tiempo atrasado, el cual es el dep_delay en valor absoluto. Tenemos:

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT aeropuerto_origen, sum(abs(dep_delay))
           FROM BASE
           GROUP BY 1
           ORDER BY 1")
```

```{r}
datos_conj %>%  dplyr::group_by(aeropuerto_origen) %>% 
  dplyr::summarise(incidentes_tot = sum(abs(dep_delay), na.rm = TRUE)) %>% 
  dplyr::arrange(desc(incidentes_tot))
```

## 4.¿Qué proporción de vuelos se retrasaron más de 30 minutos?

Alrededor del 14% de los vuelos tienen un retraso superior a 30 minutos

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.faa aeropuerto_origen, A.dest, C2.faa aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)),
           
           FINAL AS (SELECT *, datetime(time_hour, 'auto','localtime', '+1 hour') fecha,
           strftime('%w', datetime(time_hour, 'auto','localtime' )) dia_semana, 
           CASE WHEN dep_delay > 30 OR arr_delay > 30 THEN 1 ELSE 0 END retraso
           FROM BASE
           ORDER BY day)
           
           SELECT AVG(retraso), sum(retraso)/count(*)
           FROM FINAL")
```

```{r}
datos_conj %>%
  dplyr::filter(dep_delay > 30) %>% 
  dplyr::summarise(incidentes_tot = mean(dep_delay, na.rm = TRUE),
                   retrasos = sum(atrasos_total)/336776) %>% 
  dplyr::arrange(desc(incidentes_tot))
```

## 5.¿Qué destinos tuvieron los mayores retrasos promedio en la llegada?

Se puede ver, tomando el tiempo de atraso mayor a cero:

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)),
           
           FINAL AS (SELECT *, datetime(time_hour, 'auto','localtime', '+1 hour') fecha,
           strftime('%w', datetime(time_hour, 'auto','localtime' )) dia_semana, 
           CASE WHEN arr_delay > 0 THEN 1 ELSE 0 END retraso
           FROM BASE
           ORDER BY day)
           
           SELECT aeropuerto_dest, avg(retraso)
           FROM FINAL
           GROUP BY 1
           ORDER BY 2 DESC LIMIT 10")
```

```{r}
datos_conj %>%  dplyr::group_by(aeropuerto_dest) %>% 
  dplyr::summarise(incidentes_tot = mean(arr_delay, na.rm = TRUE),
                   retrasos = mean(atrasos_salida)) %>% 
  dplyr::arrange(desc(incidentes_tot))
```

## 6.¿Qué aerolíneas tuvieron el mayor número de vuelos desde NYC?

Podemos ver, tomando el tiempo de atraso mayor a cero:

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)),
           
           FINAL AS (SELECT *, CASE WHEN arr_delay > 0 THEN 1 ELSE 0 END retraso
           FROM BASE
           ORDER BY day)
           
           SELECT aerolinea, Count(*)
           FROM FINAL
           WHERE origin in ('JFK','LGA', 'EWR')
           GROUP BY 1
           ORDER BY 2 DESC")
```

```{r}
nwa <- c('JFK' , 'LGA' , 'EWR')

datos_conj %>%  dplyr::group_by(aerolinea) %>% 
  dplyr::filter(origin %in% nwa) %>% 
  dplyr::summarise(incidentes_tot = mean(arr_delay, na.rm = TRUE), n=  dplyr::n()) %>% 
  dplyr::arrange(desc(n))
```

## 7.¿Cómo varía el retraso de los vuelos según el fabricante de la aeronave?

Podemos ver por fabricante el número de atrasos, de mayor a menor.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp, A.tailnum
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)),
           
           FINAL AS (SELECT *, CASE WHEN arr_delay > 0 OR dep_delay >0 THEN 1 ELSE 0 END retraso
           FROM BASE
           ORDER BY day)
           
           SELECT manufacturer,  sum(retraso)
           FROM FINAL
           GROUP BY 1
           ORDER BY 2 DESC")
```

```{r}
datos_conj %>%  dplyr::group_by(manufacturer) %>% 
  dplyr::summarise(incidentes_tot = mean(arr_delay + dep_delay, na.rm = TRUE),
                   retraso = sum(atrasos_total)) %>% 
  dplyr::arrange(desc(retraso))
```

## 8.¿Los aviones más antiguos tienen más retrasos?

Tomando a los aviones creados antes del 2000 como antiguos, la respuesta es no, los nuevos a tienen más retrasos.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp, A.tailnum
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)),
           
           FINAL AS (SELECT *, CASE WHEN arr_delay > 0 OR dep_delay >0 THEN 1 ELSE 0 END retraso
           FROM BASE
           ORDER BY day)
           
           SELECT sum(CASE WHEN year_avion < 2000 THEN retraso END) retrasos_1900,
           sum(CASE WHEN year_avion >= 2000 THEN retraso END) retrasos_2000
           FROM FINAL")
```

```{r}
datos_conj %>% 
  dplyr::filter(year_avion < 2000) %>% 
  dplyr::summarise(incidentes_tot = mean(arr_delay+dep_delay, na.rm = TRUE)) %>% 
  dplyr::arrange(desc(incidentes_tot))

datos_conj %>% 
  dplyr::filter(year_avion >= 2000) %>% 
  dplyr::summarise(incidentes_tot = mean(arr_delay+dep_delay, na.rm = TRUE)) %>% 
  dplyr::arrange(desc(incidentes_tot))
```

## 9.¿Qué modelos de aviones se utilizan con mayor frecuencia en vuelos desde NYC?

Podemos ver:

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)),
           
           FINAL AS (SELECT *, CASE WHEN arr_delay > 0 THEN 1 ELSE 0 END retraso
           FROM BASE
           ORDER BY day)
           
           SELECT model, Count(*)
           FROM FINAL
           WHERE origin in ('JFK','LGA', 'EWR')
           GROUP BY 1
           ORDER BY 2 DESC limit 10")
```

```{r}
datos_conj %>%  dplyr::select(model,dep_delay) %>%
  dplyr::group_by(model) %>% 
  dplyr::summarise(n = dplyr::n()) %>% 
  dplyr::arrange(desc(n))
```

## 10.¿Cuál es la distancia promedio de vuelo por aerolínea?

Tenemos:

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)),
           
           FINAL AS (SELECT *, CASE WHEN arr_delay > 0 THEN 1 ELSE 0 END retraso
           FROM BASE
           ORDER BY day)
           
           SELECT aerolinea, avg(distance)
           FROM FINAL
           GROUP BY 1 ORDER BY 2 DESC")
```

```{r}
datos_conj %>%  dplyr::group_by(aerolinea) %>% 
  dplyr::summarise(incidentes_tot = mean(distance, na.rm = TRUE)) %>% 
  dplyr::arrange(desc(incidentes_tot))
```

## 11.¿Qué aeropuerto de NYC tuvo el mayor número de retrasos en la salida?

Newark Liberty Intl, definiendo los retrasos de salida como que no salen en su tiempo agendado, 
es decir, que su tiempo de retraso no sea cero.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour)),
           
           FINAL AS (SELECT *, CASE WHEN dep_delay <> 0 THEN 1 ELSE 0 END retraso
           FROM BASE
           ORDER BY day)
           
           SELECT aeropuerto_origen, sum(retraso), 
           avg(CASE WHEN dep_delay <> 0 THEN dep_delay ELSE 0 END) dep_delay_avg
           FROM FINAL
           WHERE origin in ('JFK','LGA', 'EWR')
           GROUP BY 1 ORDER BY 2 DESC")
```

```{r}
datos_conj %>%  dplyr::group_by(aeropuerto_origen) %>% 
  dplyr::filter(origin %in% nwa, dep_delay != 0) %>% 
  dplyr::summarise(incidentes_tot = mean(dep_delay, na.rm = TRUE), 
                   atrasos_salida =  sum(atrasos_salida),
                   atrasos_total = sum(atrasos_total)) %>% 
  dplyr::arrange(desc((atrasos_total)))
```

## 12.¿Qué aeropuerto tuvo el menor tiempo promedio de taxi-out?

Sea el taxi-out el tiempo transcurrido en su hora de salida y su tiempo de despegue, tomamos a dep_delay como este tiempo, ya que es la diferencia entre la hora de salida agendada del avion y su hora de retraso, es decir la hora que salio.

Con esto el aeropuerto con mas tiempo promedio de taxi-out es LGA.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT origin, avg(dep_delay)
           FROM BASE
           GROUP BY 1 
           ORDER BY 2")
```

```{r}
datos_conj %>%  dplyr::group_by(aeropuerto_origen) %>% 
  dplyr::summarise(incidentes_tot = mean(dep_delay, na.rm = TRUE)) %>% 
  dplyr::arrange(incidentes_tot)
```

## 13.¿Qué porcentaje de vuelos que salen de cada aeropuerto de NYC fueron puntuales?

Podemos ver:

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT AVG(CASE WHEN dep_delay = 0 THEN 1 ELSE 0 END) puntuales
           FROM BASE
           WHERE origin in ('JFK','LGA', 'EWR')
           ")
```

```{r}
datos_conj %>% dplyr::select(origin, dep_delay) %>% 
  dplyr::filter(dep_delay == 0) %>% 
  dplyr::summarise(n = dplyr::n()/336776)
```

## 14.¿Qué aeropuertos de destino tienen el mayor retraso promedio en la llegada para vuelos desde NYC?

En tiempo de retraso Columbia Metropolitan, en promedio Hartsfield Jackson Atlanta Intl

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT aeropuerto_dest, avg(arr_delay)
           FROM BASE
           WHERE origin in ('JFK','LGA', 'EWR')
           GROUP BY 1 ORDER BY 2 DESC LIMIT 10")
```

```{r}
datos_conj %>%  dplyr::group_by(aeropuerto_dest) %>% 
  dplyr::filter(origin %in% nwa) %>% 
  dplyr::summarise(incidentes_tot = mean(arr_delay, na.rm = TRUE),
                   retraso = sum(atrasos_llegada)/336776) %>% 
  dplyr::arrange(desc(retraso))
```

## 15.¿Cómo varían los retrasos en la salida según la hora del día en cada aeropuerto de NYC?

Podemos ver que de las 19 a 21 hrs son las horas con mas tiempo de retraso en promedio.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT hour, avg(dep_delay)
           FROM BASE
           GROUP BY 1 ORDER BY 1")
```

```{r}
datos_conj %>%  dplyr::group_by(hour) %>% 
  dplyr::summarise(avg = mean(dep_delay, na.rm = TRUE)) %>% 
  dplyr::arrange(desc(avg))
```

## 16.¿Cuál es la correlación entre la velocidad del viento y los retrasos en la salida?

Tenemos una correlacion de 0.04, una correlación muy baja.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp,
           humid, wind_dir, wind_speed, wind_gust, precip, pressure, visib
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT
           (COUNT(*) * SUM(dep_delay * wind_speed) - SUM(dep_delay) * SUM(wind_speed)) /(SQRT(COUNT(*) * SUM(POWER(dep_delay, 2)) - POWER(SUM(dep_delay), 2)) * SQRT(COUNT(*) * SUM(POWER(wind_speed, 2)) - POWER(SUM(wind_speed), 2)))
           AS correlacion
           FROM BASE")
```

```{r}
datos_conj %>% 
  dplyr::filter(!is.na(dep_delay), !is.na(wind_speed)) %>% 
  dplyr::summarise(incidentes_tot = cor(dep_delay,wind_speed)) %>% 
  dplyr::arrange(desc(incidentes_tot))
```

## 17.¿Los vuelos experimentan más retrasos en días con lluvias intensas?

Mientras menos precipitación en pulgadas hay, mas atrasos tenemos, entonces no, sin embargo, precipitaciones altas tiene un tiepo mayor de retraso.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp,
           humid, wind_dir, wind_speed, wind_gust, precip, pressure, visib
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT precip, SUM(CASE WHEN dep_delay > 0 and arr_delay > 0 THEN 1 ELSE 0 END) delays
           FROM BASE
           GROUP BY 1 ORDER BY 1")
```

```{r}
datos_conj %>%  dplyr::group_by(precip) %>% 
  dplyr::summarise(avg = mean(dep_delay, na.rm = TRUE), 
                   atrasos_salida = sum(atrasos_salida),
                   atrasos_total = sum(atrasos_total)) %>% 
  dplyr::arrange(desc(precip))
```

## 18.¿Cómo afecta la temperatura a los retrasos de los vuelos?

Entre 35 y 40 de temperatura se tiene el mayor número de atrasos

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp,
           humid, wind_dir, wind_speed, wind_gust, precip, pressure, visib
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT CASE 
           WHEN temp <= 5 THEN 'A. 0-5 temp'
           WHEN temp <= 10 THEN 'B. 5-10 temp'
           WHEN temp <= 15 THEN 'C. 10-15 temp'
           WHEN temp <= 20 THEN 'D. 15-20 temp'
           WHEN temp <= 25 THEN 'E. 20-25 temp'
           WHEN temp <= 30 THEN 'F. 25-30 temp'
           WHEN temp <= 35 THEN 'G. 30-35 temp'
           WHEN temp <= 40 THEN 'H. 35-40 temp'
           WHEN temp <= 45 THEN 'I. 40-45 temp'
           WHEN temp <= 50 THEN 'J. 45-50 temp'
           WHEN temp <= 55 THEN 'K. 50-55 temp'
           WHEN temp <= 60 THEN 'L. 55-60 temp'
           WHEN temp <= 65 THEN 'M. 60-65 temp'
           WHEN temp <= 70 THEN 'N. 65-70 temp'
           WHEN temp <= 75 THEN 'O. 70-75 temp'
           WHEN temp <= 80 THEN 'P. 75-80 temp'
           WHEN temp <= 85 THEN 'Q. 80-85 temp'
           WHEN temp <= 90 THEN 'R. 85-90 temp'
           WHEN temp <= 95 THEN 'S. 90-95 temp'
           WHEN temp <= 100 THEN 'T. 95-100 temp'
           WHEN temp <= 105 THEN 'U. 100-105 temp' END temp, 
           SUM(CASE WHEN dep_delay > 0 and arr_delay > 0 THEN 1 ELSE 0 END) delays
           FROM BASE
           GROUP BY 1 ORDER BY 2")
```

```{r}
datos_conj_1 <- datos_conj %>% dplyr::mutate(temp_rank1 = dplyr::case_when(temp <= 5 ~ 'A. 0-5 temp',
                                          temp <=  10 ~ 'B. 5-10 temp',
                                          temp <= 15 ~ 'C. 10-15 temp',
                                          temp <= 20 ~ 'D. 15-20 temp',
                                          temp <= 25 ~ 'E. 20-25 temp',
                                          temp <= 30 ~ 'F. 25-30 temp',
                                          temp <= 35 ~ 'G. 30-35 temp',
                                          temp <= 40 ~ 'H. 35-40 temp',
                                          temp <= 45 ~ 'I. 40-45 temp',
                                          temp <= 50 ~ 'J. 45-50 temp',
                                          temp <= 55 ~ 'K. 50-55 temp',
                                          temp <= 60 ~ 'L. 55-60 temp',
                                          temp <= 65 ~ 'M. 60-65 temp',
                                          temp <= 70 ~ 'N. 65-70 temp',
                                          temp <= 75 ~ 'O. 70-75 temp',
                                          temp <= 80 ~ 'P. 75-80 temp',
                                          temp <= 85 ~ 'Q. 80-85 temp',
                                          temp <= 90 ~ 'R. 85-90 temp',
                                          temp <= 95 ~ 'S. 90-95 temp',
                                          temp <= 100 ~ 'T. 95-100 temp',
                                          temp <= 105 ~ 'U. 100-105 temp' ),
                      temp_rank2 = dplyr::case_when(temp <= 10 ~ 'A. 0-10 temp',
                                             temp <= 20 ~ 'B. 10-20 temp',
                                             temp <= 30 ~ 'C. 20-30 temp',
                                             temp <= 40 ~ 'D. 30-40 temp',
                                             temp <= 50 ~ 'E. 40-50 temp',
                                             temp <= 60 ~ 'F. 50-60 temp',
                                             temp <= 70 ~ 'G. 60-70 temp',
                                             temp <= 80 ~ 'H. 70-80 temp',
                                             temp <= 90 ~ 'I. 80-90 temp',
                                             temp <= 100 ~ 'J. 90-100 temp',
                                             temp <= 110 ~ 'K. 100-110 temp' ),
                      cuenta = dplyr::case_when(dep_delay != 0 ~ 1,
                                             TRUE ~ 0))

datos_conj_1 %>% summary()

datos_conj_1 %>%  dplyr::group_by(temp_rank1) %>% 
  dplyr::summarise(avg = mean(dep_delay, na.rm = TRUE), 
                   sd = sd(dep_delay, na.rm = TRUE),
                   var = var(dep_delay, na.rm = TRUE),
                   count = sum(cuenta)) %>% 
  dplyr::arrange(temp_rank1)

datos_conj_1 %>%  dplyr::group_by(temp_rank2) %>% 
  dplyr::summarise(avg = mean(dep_delay, na.rm = TRUE), 
                   sd = sd(dep_delay, na.rm = TRUE),
                   var = var(dep_delay, na.rm = TRUE),
                   count = sum(cuenta)) %>% 
  dplyr::arrange(temp_rank2)
```

## 19.¿Cómo afectan los niveles de visibilidad a los retrasos en la llegada?

Mientras más alto el número de visibilidad mayor los atrasos.

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp,
           humid, wind_dir, wind_speed, wind_gust, precip, pressure, visib
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT visib,
           SUM(CASE WHEN arr_delay > 0 THEN 1 ELSE 0 END) delays
           FROM BASE
           GROUP BY 1 ORDER BY 2 DESC")
```

```{r}
datos_conj_1 %>%  dplyr::group_by(visib) %>% 
  dplyr::summarise(avg = mean(dep_delay, na.rm = TRUE),
                   count = sum(cuenta)) %>% 
  dplyr::arrange(desc(visib))

```

## 20.¿La alta humedad se relaciona de alguna manera con los tiempos de taxi-out más largos?

Después de 65 de humedad se tiene mayor taxi-out

```{r}
dbGetQuery(conn, "WITH BASE AS (SELECT B.name aerolinea, A.year, A.month, A.day, A.dep_time, A.sched_dep_time,
           A.dep_delay, A.arr_time, A.sched_arr_time, A.arr_delay, A.flight, A.air_time, A.distance,
           A.hour, A.minute, A.time_hour, A.origin, C1.name aeropuerto_origen, A.dest, C2.name aeropuerto_dest,
           D.year year_avion, D.type, D.manufacturer, D.model, D.engines, D.seats, D.speed, D.engine,
           E.year year_clima, E.month month_clima, E.day day_clima, E.hour hour_clima, temp, dewp,
           humid, wind_dir, wind_speed, wind_gust, precip, pressure, visib
           FROM vuelos AS A 
           LEFT JOIN aerolineas AS B 
           ON A.carrier = B.carrier
           LEFT JOIN aeropuertos AS C1 
           ON A.origin = C1.faa
           LEFT JOIN aeropuertos AS C2 
           ON A.dest = C2.faa
           LEFT JOIN aviones AS D 
           ON A.tailnum = D.tailnum
           LEFT JOIN clima AS E 
           ON (A.origin = E.origin AND A.time_hour = E.time_hour))
           
           SELECT CASE 
           WHEN humid <= 5 THEN 'A. 0-5 humid'
           WHEN humid <= 10 THEN 'B. 5-10 humid'
           WHEN humid <= 15 THEN 'C. 10-15 humid'
           WHEN humid <= 20 THEN 'D. 15-20 humid'
           WHEN humid <= 25 THEN 'E. 20-25 humid'
           WHEN humid <= 30 THEN 'F. 25-30 humid'
           WHEN humid <= 35 THEN 'G. 30-35 humid'
           WHEN humid <= 40 THEN 'H. 35-40 humid'
           WHEN humid <= 45 THEN 'I. 40-45 humid'
           WHEN humid <= 50 THEN 'J. 45-50 humid'
           WHEN humid <= 55 THEN 'K. 50-55 humid'
           WHEN humid <= 60 THEN 'L. 55-60 humid'
           WHEN humid <= 65 THEN 'M. 60-65 humid'
           WHEN humid <= 70 THEN 'N. 65-70 humid'
           WHEN humid <= 75 THEN 'O. 70-75 humid'
           WHEN humid <= 80 THEN 'P. 75-80 humid'
           WHEN humid <= 85 THEN 'Q. 80-85 humid'
           WHEN humid <= 90 THEN 'R. 85-90 humid'
           WHEN humid <= 95 THEN 'S. 90-95 humid'
           WHEN humid <= 100 THEN 'T. 95-100 humid' END humid,
           avg(dep_delay)
           FROM BASE
           GROUP BY 1
           ORDER BY 2 DESC")
```

```{r}
datos_conj_2 <- datos_conj_1 %>% dplyr::mutate(humid_rank1 = dplyr::case_when(humid <= 5 ~ 'A. 0-5 humid',
                                                              humid <=  10 ~ 'B. 5-10 humid',
                                                              humid <= 15 ~ 'C. 10-15 humid',
                                                              humid <= 20 ~ 'D. 15-20 humid',
                                                              humid <= 25 ~ 'E. 20-25 humid',
                                                              humid <= 30 ~ 'F. 25-30 humid',
                                                              humid <= 35 ~ 'G. 30-35 humid',
                                                              humid <= 40 ~ 'H. 35-40 humid',
                                                              humid <= 45 ~ 'I. 40-45 humid',
                                                              humid <= 50 ~ 'J. 45-50 humid',
                                                              humid <= 55 ~ 'K. 50-55 humid',
                                                              humid <= 60 ~ 'L. 55-60 humid',
                                                              humid <= 65 ~ 'M. 60-65 humid',
                                                              humid <= 70 ~ 'N. 65-70 humid',
                                                              humid <= 75 ~ 'O. 70-75 humid',
                                                              humid <= 80 ~ 'P. 75-80 humid',
                                                              humid <= 85 ~ 'Q. 80-85 humid',
                                                              humid <= 90 ~ 'R. 85-90 humid',
                                                              humid <= 95 ~ 'S. 90-95 humid',
                                                              humid <= 100 ~ 'T. 95-100 humid',
                                                              humid <= 105 ~ 'U. 100-105 humid' ),
                                      humid_rank2 = dplyr::case_when(humid <= 10 ~ 'A. 0-10 humid',
                                                              humid <= 20 ~ 'B. 10-20 humid',
                                                              humid <= 30 ~ 'C. 20-30 humid',
                                                              humid <= 40 ~ 'D. 30-40 humid',
                                                              humid <= 50 ~ 'E. 40-50 humid',
                                                              humid <= 60 ~ 'F. 50-60 humid',
                                                              humid <= 70 ~ 'G. 60-70 humid',
                                                              humid <= 80 ~ 'H. 70-80 humid',
                                                              humid <= 90 ~ 'I. 80-90 humid',
                                                              humid <= 100 ~ 'J. 90-100 humid',
                                                              humid <= 110 ~ 'K. 100-110 humid' ),
                                      cuenta = dplyr::case_when(dep_delay != 0 ~ 1,
                                                         TRUE ~ 0))


datos_conj_2 %>%  dplyr::group_by(humid_rank1) %>% 
  dplyr::summarise(avg = mean(dep_delay, na.rm = TRUE)) %>% 
  dplyr::arrange(desc(humid_rank1))

datos_conj_2 %>%  dplyr::group_by(humid_rank2) %>% 
  dplyr::summarise(avg = mean(dep_delay, na.rm = TRUE)) %>% 
  dplyr::arrange(desc(humid_rank2))
```


## Subsección 2

Se usará el conjunto de datos de encuesta de café

```{r}
datos_coffee <- readr::read_csv("coffee_ratings.csv")
```

#### Actividad 0: Realice un análisis de valores faltantes del objeto datos

```{r}
# Primero, hagamos un análisis simple, para tener más información sobre las variables
# del dataset de `coffe_ratings.


summary(datos_coffee)
```

```{r}
ncol(datos_coffee)
```

Tenemos 1339 observaciones con 43 columnas. Por practicidad y facilidad de la lectura,
usemos la función `gg_miss_var` de la paquetería naniar. 

```{r}
naniar::gg_miss_var(datos_coffee)
``` 
Como podemos ver, practivamente la variable asociada al número de lote está vacia 
o con muchos NA`s. A partir de aquí, dado que tenemos 1339 observaciones, 
tenemos que las demás variables no presentan más del 33% de datos faltantes. 

#### Actividad 1: Crear una columna llamada color2 que se base en los valores de la columna color, que asigne el valor NA si color == NA, "#00FF66" si color == 'Green', "#CCEBC5" si color == 'Bluish-green' y "#BFFFFF" si color == 'Blue-green'

```{r}

datos_coffee <- datos_coffee |> dplyr::mutate(color2 = color |> dplyr::case_match(
  "Green" ~ "#00FF66",
  "Bluish-Green" ~ "#CCEBC5",
  "Blue-Green" ~ "#BFFFFF",
  .default = NA
))
```


#### Actividad 2: Crear una columna llamada bag_weight2 que se base en los valores de la columna bag_weight, que sólo contenga el valor numérico de ésta. Es decir, bag_weight2 debe ser numérica. ¿Cuántas observaciones llevaron a ambigüedad para crear esta nueva columna?

Para resolver esta duda, notemos un poco los valores de esta columna. Del primer paso,
notamos que estamos manipulanto textos.
```{r}
datos_coffee$bag_weight
```
Por lo mostrado en la terminal, tenemos casos ambiguos como "1 kg,lbs" donde tenemos
dos sistemas métricos indicando la misma cantidad, lo cual pareciese ambiguo. 

Por lo mismo, procedomos a crear la columna con el valor numerico. Por simplicidad, 
usaremos un regex para obtener solo el valor numérico.

```{r}
datos_coffee <- datos_coffee |>
  dplyr::mutate(bag_weight2 = as.numeric(regmatches(bag_weight,regexpr("[0-9]+",bag_weight))))
```

```{r}
sum(is.na(datos_coffee$bag_weight2) & !is.na(datos_coffee$bag_weight))
```


Para saber cuantas llevaron a la ambiguedad antes mencionada por el uso
de distintos sistmas de medición,
```{r}
#foo <- datos_coffee |>
#  dplyr::mutate(a =
#                  gsub("[0-9]+\\s*", "", bag_weight) |> #strsplit(",")
#  )

count_sistema_numericos <- function(a) {
  gsub("[0-9]+\\s*", "", a) |> strsplit(",") |> unlist() |> length()
} 

sistemas_numericos <- lapply(datos_coffee$bag_weight, count_sistema_numericos) |> as.numeric()

sistemas_numericos[sistemas_numericos != 1] |> length()
```
Tenemos que hay 29 observaciones con la ambiguedad de los sistemas numéricos.

#### Actividad 3: Crear dos columnas llamadas method1 y method2 que se basen en los valores de la columna processing_method, dividiendo en dos partes los valores dicha columna. ¿Cuántas observaciones llevaron a ambigüedad para crear esta nueva columna?

Verifiquemos primero los datos. 
```{r}
datos_coffee$processing_method
```
Tenemos que los datos a extraer están separados por el character ¨/"

La parte ambigua la obtenemos por los datos faltantes. 

Obtengamos la columnas buscadas. 

```{r}
datos_coffee <- datos_coffee |> 
  separate(processing_method, into = c("method1", "method2"), sep = "/", remove = FALSE)

no_ambiguedades <- datos_coffee %>%
  mutate(n_methods = lengths(strsplit(processing_method, "/"))) %>%
  filter(n_methods == 2)

nrow(no_ambiguedades)

```

Tenemos que hay 1143 elementos sin ambiguedades porque tienen bien 
definidos los dos métodos. Por lo tanto, hay 196 ambiguedades. 

#### Actividad 4: Crear tres columnas llamadas expiration_day, expiration_month y expiration_year que se basen en los valores de la columna expiration. ¿Cuántas observaciones llevaron a ambigüedad para crear estas nuevas columnas?

Verifiquemos los datos de la columna `expiration`. 

```{r}
datos_coffee$expiration |> head(20)
```

Tenemos que es un formato de fecha por mes, día y año. Por lo que una ambiguedad sería tener alguna obersación que no contenga exactamente estos tres valores. 



```{r}
no_ambiguedades <- datos_coffee %>%
  mutate(n_methods = lengths(strsplit(expiration, " "))) %>%
  filter(n_methods == 3)

nrow(no_ambiguedades)
```

De lo cual, obtenemos que no tenemos ambiguedades en este caso. 

Procedemos a crear las columnas correspondientes. 

```{r}
datos_coffee <- datos_coffee |> 
  dplyr::mutate(expiration_year =  mdy(expiration) |> year(),
                expiration_month =  mdy(expiration) |> month(),
                expiration_day =  mdy(expiration) |> day())
```


#### Actividad 5: Crear dos columnas llamadas harvest_mes y harvest_anio que se basen en los valores de la columna harvest_year, dividiendo en dos partes los valores dicha columna. ¿Cuántas observaciones llevaron a ambigüedad para crear esta nueva columna?

Veamos primero la columna `harvest_year`. 

```{r}
datos_coffee$harvest_year |> head(1000)
```

Tenemos diversas ambiguedades como por ejemplo, casos sin mes e intervalos de tiempo. Hasta hay un caso con la palabra `TEST`. 

Por simplicidad, vamos a mapear estos datos con la info que se tiene. Se considerará ambiguo cuando alguno de los datos (año o mes) esté ausente. 

```{r}

get_maybe_year <- function(s) {
  maybe_year <- regmatches(s,regexpr("[0-9]{4}",s)) # Consideramos solo el primer año que aparezca
  if( maybe_year |> identical(character(0))) {
    NA
  } else {
    maybe_year
  }
}

get_maybe_month <- function(s) {
  maybe_match <- regmatches(s,regexpr("[a-zA-Z]+",s)) # Consideramos solo el primer mes que aparezca
  if( maybe_match |> identical(character(0))) {
    NA
  } else {
    maybe_match
  }
}

#Agregamos los datos 
datos_coffee$harvest_anio <- lapply(datos_coffee$harvest_year, get_maybe_year) |> unlist()
datos_coffee$harvest_mes <- lapply(datos_coffee$harvest_year, get_maybe_month) |> unlist()

ambiguas <- datos_coffee %>%
  filter(is.na(harvest_anio) | is.na(harvest_mes))

nrow(ambiguas)
```

En este caso, tenemos 1319 elementos ambiguos donde no conocemos o el año o el mes. 


#### Actividad 6: Elabore una visualización con {ggplot2} que identifique alguna relación entre las columnas total_cup_points, acidity y color2 de tal forma que se puedan identificar los colores de la variable color2. Es decir, debemos ver los colores, "#00FF66", "#CCEBC5" y "#BFFFFF".

```{r}

numero_completo <- function(x) format(x, big.mark = ",", scientific = FALSE)

datos_coffee |> filter(acidity > 0 & total_cup_points > 0 ) |>  mutate(color_label = as.factor(color2)) |>
ggplot(aes(x = acidity, y = total_cup_points, color = color_label)) +
  geom_point() +
   scale_x_continuous(labels = numero_completo, transform = "log10") +
  scale_color_manual(values=c("#00FF66", "#BFFFFF",  "#CCEBC5", "#000000")) + 
  labs(color = "Color en hexagecimal") + 
  scale_y_continuous(labels = numero_completo, transform = "log10") +
  labs(title = "Relación entre Total Cup Points, Acidity y Color2")
```

Podemos notar que hay una correlación positiva entre la columna `acidity` y `total_cup_points`. 

#### Actividad 7: Elabore una visualización de densidad con {ggplot2} de la variable bag_weight2 diferenciando a los valores de species.

```{r}
datos_coffee |> 
  filter(bag_weight2 > 0) |>
ggplot(aes(x = bag_weight2, fill = species)) +
  scale_x_continuous(labels = numero_completo, transform = "log10") +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Densidad de bag_weight2 por species", fill = "Especie")
```

```{r}
#Solo tenemos dos tipos de especies
datos_coffee$species |> unique()

#Tenemos 4 observacion con valor 0. Por simplicidad, las vamos a omitir. 
datos_coffee$bag_weight2[datos_coffee$bag_weight2 == 0] |> length()
```

#### Actividad 8: Elabore una visualización que relacione el año/mes de expiración con el total_cup_points sólo de los granos mexicanos, brasileños, colombianos y guatemaltecos.

```{r}
#Checar paises de origen
#datos_coffee$country_of_origin |> unique()
paises_validos <- c("Mexico", "Brazil", "Colombia", "Guatemala")

q <- datos_coffee |>
  filter(country_of_origin %in% paises_validos) |>
  ggplot(aes(x = interaction(expiration_year), y = total_cup_points, color = country_of_origin)) +
  ggtitle("Total de cup points por año y país") + 
  geom_boxplot() +
  facet_wrap(~country_of_origin) +
   labs(y = "Total de puntos cup", x = "Año", color = "Pais de origen") 

q + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

```{r}
q <- datos_coffee |>
  filter(country_of_origin %in% paises_validos) |>
  ggplot(aes(x = interaction(expiration_month), y = total_cup_points, color = country_of_origin)) +
  ggtitle("Total de cup points por mes y país") + 
  geom_boxplot() +
  facet_wrap(~country_of_origin) +
   labs(y = "Total de puntos cup", x = "Mes", color = "Pais de origen") 

q + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

De ambas partes, podemos ver como Brsil y Colombia tienes puntajes menos variables. 


#### Actividad 9: Elabore una visualización con {ggplot2} que relacione el mes de expiración con el altitude_mean_meters, altitude_low_meters y altitude_high_meters sólo de los granos mexicanos, brasileños, colombianos y guatemaltecos de los años de expiración 2016 y 2017.

```{r}
datos_coffee |>
  filter(country_of_origin %in% paises_validos) |> # Por pais
  filter(2016 <= expiration_year &  expiration_year <= 2017) |>
ggplot(aes(x = interaction(expiration_month))) +
  geom_point(aes(y = altitude_low_meters, color = "Low"), alpha = 1) +
  geom_point(aes(y = altitude_mean_meters, color = "Mean"), alpha = 1) +
  geom_point(aes(y = altitude_high_meters, color = "High"), alpha = 1) +
  scale_color_manual(values=c("red", "black",  "blue")) +
  facet_wrap(~country_of_origin) +
  labs(title = "Alturas por mes de expiración (2016 y 2017)", y = "Altitud (m)", color = "Tipo de Altura")
```


#### Actividad 10: Elabore una visualización con {ggplot2} que relacione el aftertaste, acidity, body y species en un mismo canvas.

Como las columnas "aftertaste", "acidity"y "body" están sobre el mismo rango de valores, conviene hacer un boxplot por cada columna y
separarla por las especies. 

```{r}

datos_long <- pivot_longer(datos_coffee, cols = c("aftertaste", "acidity", "body"), names_to = "variable_pivote", values_to = "valor")

ggplot(datos_long, aes(x = species, y = valor, fill = species)) +
  geom_boxplot() +
  facet_wrap(~variable_pivote) +
  theme_minimal() +
  labs(y = "Valor", x = "", fill = "Especie") +
  labs(title = "Comparación por species: Aftertaste, Acidity, Body")
```

## Subsección 3 
Analizando letras de canciones
Se utilizarán los archivos contenidos en la carpeta comprimida canciones.zip.



```{r}
#Definimos los datos con los que vamos a trabajar
datos_ariana_grande <- read.csv("ArianaGrande.csv")
datos_beyonce <- read.csv("Beyonce.csv")
datos_billie_ellish <- read.csv("BillieEilish.csv")
datos_rihanna <- read.csv("Rihanna.csv")
datos_lady_gaga <- read.csv("LadyGaga.csv")
datos_drake <- read.csv("Drake.csv")
datos_justin_bieber <- read.csv("JustinBieber.csv")
datos_eminem <- read.csv("Eminem.csv")
datos_ed_sheeran <- read.csv("EdSheeran.csv")
datos_post_malone <- read.csv("PostMalone.csv")
datos_BTS <- read.csv("BTS.csv")
```


```{r}
#Definimos una función para generar las nubes de palabras
#En el argumento utilizaremos: 
#último_album:el df del último album,
#palabras_sinsentido: Un vector las palabras que no encontremos con sentido que sean especificas que no hemos podido eliminar con el tratamiento previo. 
#en caso de no ver necesario estas palabras simplemente dejar un vector vacio (sirve para la primera ejecución)
#maximo_palabras: Un número que sirva como máximo de palabras en la nube
#paleta_color_rcolorbrewer: Un string con la paleta de color de RColorBrewer preferida

nube_palabras <- function(ultimo_album, palabras_sinsentido, maximo_palabras, paleta_color_rcolorbrewer){
#Escogemos la columna donde estan las letras
   ultimo_album$Lyric %>% 
#Utilizamos la librerías quanteda para separar el texto y
#eliminar proposiciones, articulos, números, signos de puntuación en inglés (el idioma de la 
#la mayoría de las canciones)
        tokens() %>% tokens_remove(stopwords("english")) %>% tokens_remove( palabras_sinsentido ) %>% 
    tokens(remove_separators = TRUE,
                  remove_punct = TRUE,
                  remove_symbols = TRUE,
                  remove_numbers = TRUE)%>%
#hacemos una tabla de frecuencias de las palabras queridas y generamos la nube de palabras
#escogemos parametros que consideramos esteticos de la nube de palabras.
    dfm() %>%
    textplot_wordcloud(min_count = 5,
                     max_words = maximo_palabras,
                     font = "mono",
                    color =  RColorBrewer::brewer.pal(8, paleta_color_rcolorbrewer),
                     comparison = FALSE)

}
```


```{r}
#Definimos una función para encontrar el nombre del último disco.
#Consideramos el último disco aquel valor que este en la fila de albúm que sea el más reciente en fecha que tenga más de 5 canciones
#El argumento es: El dataframe con el que vamos a trabajar.
encontrar_album <- function(df) {
#Separamos las columnas de interés, hacemos un formato de fecha estandarizado la columna Date y además ordenamos del más reciente 
#al más viejo para encontrar el primero que se repita 5 veces
  df <- df %>% mutate(Date= ymd(as.Date(Date))) %>% select(Album,  Date, Lyric) %>% arrange(desc(Date))
#escogemos la columna cuyo valor es que queremos observar y eliminamos valores de album vacios o NAs
  col_values <- df$Album
  col_values <- col_values[!is.na(col_values) & col_values != ""]
#hacemos un ciclo for para ir recorriendo cada fila y que avance el contador hasta llegar a 5.
  contador <- 1
  for (i in 2:length(col_values)) {
    if (col_values[i] == col_values[i - 1]) {
      contador <- contador + 1
    } else {
      contador <- 1
    }
#Regresa el valor del nombre del disco según nuestro criterio
    if (contador == 5) {
      return(col_values[i])
    }
  }
#Regresa un NA en caso de no encontrar un valor con nuestro criterio
  return(NA)  
}

```



### Actividad 1.

Haga una nube de palabras de las canciones del último disco de Ariana Grande, Beyonce, Billie Eilish, Rihanna y Lady Gaga por separado, i.e. una nube por artista.

#### Ariana Grande

```{r}
nombre_album_ariana <- datos_ariana_grande %>% encontrar_album()
nombre_album_ariana
```

```{r}
ultimo_album_ariana  <- datos_ariana_grande %>% filter(Album ==nombre_album_ariana) %>% select(Artist, Title, Album, Lyric)
nube_palabras(ultimo_album_ariana,c("hey","oh","yeah") , 100, "Paired")
```


#### Beyoncé.

```{r}
nombre_album_beyonce <- datos_beyonce %>% encontrar_album()
```

```{r}
ultimo_album_beyonce <- datos_beyonce %>% filter(Album ==nombre_album_beyonce) %>% select(Artist, Title, Album, Lyric)
nube_palabras(ultimo_album_beyonce,c("hey","oh","yeah") , 100, "Paired")
```


#### Billie Eilish 

```{r}
nombre_album_billie <- datos_billie_ellish %>% encontrar_album()
nombre_album_billie
```

```{r}
ultimo_album_billie <- datos_billie_ellish %>% filter(Album ==nombre_album_billie) %>% select(Artist, Title, Album, Lyric)
nube_palabras(ultimo_album_billie,c("hey","oh","yeah") , 100, "Paired")
```

#### Rihanna 

```{r}
nombre_album_rihanna <- datos_rihanna %>% encontrar_album()
nombre_album_rihanna
```

```{r}
ultimo_album_rihanna <- datos_rihanna %>% filter(Album ==nombre_album_rihanna) %>% select(Artist, Title, Album, Lyric)
nube_palabras(ultimo_album_rihanna,c("hey","oh","yeah") , 100, "Paired")
```


#### Lady Gaga



```{r}
nombre_album_lady_gaga <- datos_lady_gaga %>% encontrar_album()
nombre_album_lady_gaga
```

```{r}
ultimo_album_lady_gaga <- datos_lady_gaga %>% filter(Album ==nombre_album_lady_gaga) %>% select(Artist, Title, Album, Lyric)
ultimo_album_lady_gaga
ultimo_album_ariana
```

```{r}
ultimo_album_lady_gaga <- datos_lady_gaga %>% filter(Album ==nombre_album_lady_gaga)
nube_palabras(ultimo_album_lady_gaga,c("hey","oh","yeah","ooh","ah") , 100, "Paired")
```


### Actividad 2

Haga una nube de palabras de las canciones del último disco de Ariana Grande, Beyonce, Billie Eilish, Rihanna y Lady Gaga combinados, i.e. una única nube.

```{r}
artistas <- bind_rows(ultimo_album_lady_gaga, ultimo_album_rihanna, ultimo_album_beyonce,ultimo_album_billie,ultimo_album_ariana)
```

```{r}
nube_palabras(artistas,c("hey","oh","yeah","ooh","ah","mmm","um") , 500, "Set1")
```

### Actividad 3

Haga una nube de palabras de las canciones del último disco de Drake, Justin Bieber, Eminem, Ed Sheeran y Post Malone por separado, i.e. una nube por artista.

#### Drake
```{r}
nombre_album_drake <- datos_drake %>% encontrar_album()
nombre_album_drake
```

```{r}
ultimo_album_drake <- datos_drake %>% filter(Album ==nombre_album_drake) %>% select(Artist, Title, Album, Lyric)
nube_palabras(ultimo_album_drake,c("hey","oh","yeah","ooh","ah","ayy") , 100, "Dark2")
```

#### Justin Bieber

```{r}
nombre_album_justin <- datos_justin_bieber %>% encontrar_album() 
nombre_album_justin
```

```{r}
ultimo_album_justin <- datos_justin_bieber %>% filter(Album ==nombre_album_justin) %>% select(Artist, Title, Album, Lyric)
nube_palabras(ultimo_album_justin,c("hey","oh","yeah","ooh","ah","ayy") , 100, "Dark2")
```


#### Eminem

```{r}
nombre_album_eminem <- datos_eminem %>% encontrar_album()
nombre_album_eminem
```

```{r}
ultimo_album_eminem <- datos_eminem %>% filter(Album ==nombre_album_eminem) %>% select(Artist, Title, Album, Lyric)
nube_palabras(ultimo_album_eminem,c("hey","oh","yeah","ooh","ah","ayy") , 100, "Dark2")
```


#### Ed Sheeran

```{r}
nombre_album_ed <- datos_ed_sheeran %>% encontrar_album()
nombre_album_ed
```

```{r}
ultimo_album_ed <- datos_ed_sheeran %>% filter(Album ==nombre_album_ed) %>% select(Artist, Title, Album, Lyric)
nube_palabras(ultimo_album_ed,c("hey","oh","yeah","ooh","ah","ayy") , 100, "Dark2")
```


#### Post Malone
```{r}
nombre_album_post <- datos_post_malone %>% encontrar_album()
nombre_album_post
```

```{r}
ultimo_album_post <- datos_post_malone %>% filter(Album ==nombre_album_post) %>% select(Artist, Title, Album, Lyric)
nube_palabras(ultimo_album_post,c("hey","oh","yeah","ooh","ah","ayy") , 100, "Dark2")
```



### Actividad 4  

Haga una nube de palabras de las canciones del último disco de Drake, Justin Bieber, Eminem, Ed Sheeran y Post Malone combinados, i.e. una única nube.

```{r}
artistos <- bind_rows(ultimo_album_drake, ultimo_album_justin, ultimo_album_eminem, ultimo_album_ed, ultimo_album_post)
```
```{r}
nube_palabras(artistos,c("hey","oh","yeah","ooh","ah","mmm","wow") , 500, "Set2")
```



### Actividad 5

Haga una nube de palabras de las canciones de los últimos 3 discos de BTS combinados, i.e. una única nube.

```{r}
datos_BTS %>% mutate(Date= ymd(as.Date(Date))) %>% select(Album,  Date, Lyric) %>% arrange(desc(Date))
```

```{r}
ultimo_album_BTS1 <- datos_BTS %>% filter(Album =="BE")
ultimo_album_BTS2 <- datos_BTS %>% filter(Album == "Dynamite (NightTime Version)")
ultimo_album_BTS3 <- datos_BTS %>% filter(Album == "MAP OF THE SOUL: 7 ~ The Journey ~")
ultimo_album_BTS_completo <- bind_rows(ultimo_album_BTS1, ultimo_album_BTS2, ultimo_album_BTS3)
nube_palabras(ultimo_album_BTS_completo,c("hey","oh","yeah","ooh","ah","ayy") , 500, "RdYlGn")
```

Para hacer más fácil el análisis posterior vamos a limpiar las canciones de los discos que este vacías en la columna de Lyric

```{r}
letras_limpias <- ultimo_album_BTS_completo %>%
  filter(!is.na(Lyric)) %>%
  mutate(Lyric = gsub("\n", " ", Lyric))  
```

```{r}
#Hagamos una función para analizar de nuestras letras que tipos de caracter codificados   UNICODE (https://symbl.cc/es/unicode-table/) y como se expresan como una expresión regex y como argumento solo queremos usar una sola columna.
#Como además al correr esta función solamente con coreano no hemos encontrado otros caracteres que parecen asiaticos hemos decidido añadir otros idiomaas de la región
#Vamos a usar la librería stri para encontrar los caracteres y poder contarlos.
contar_simbolos <- function(texto) {
  #hacemos una lista de los caracteres que queremos identificar
  categorias <- list(
    Latin      = "[A-Za-z]",
    Numeros    = "[0-9]",
    Coreano    = "[\\uAC00-\\uD7AF]",
    JaponesHiragana   = "[\\u3040-\\u309F]",
    JaponesKatakana   = "[\\u30A0-\\u30FF]",
    Chino      = "[\\u4E00-\\u9FFF]",
    Espacios = "[[:space:]]",
    Puntuacion = "[[:punct:]]"
   
  )
  #usamos la función sapply para divirlo por categorias y usamos la función stri_count_regex
  conteos <- sapply(categorias, function(patron) {
    sum(stri_count_regex(texto, patron))
  })
}


texto <-  letras_limpias$Lyric


#Estas líneas nos indican simplemente que tantos caracteres no hemos identificado respecto al total, no son muchos.
simbolos_encontrados <- contar_simbolos(texto) %>% sum() 
simbolos_totales <- texto %>% nchar() %>% sum()

simbolos_encontrados  - simbolos_totales
```



```{r}
#Hacemos otra función para poder extraer los simbolos por tipo usando su expresión regular (regex) y un texto. Esto es así para que se puedan traducir por idioma cada uno de los caracteres.

extraer_simbolos <- function(texto, expresion_regex_idioma) {
  # Se usa la función stri_extract_all_regex() para extraerlos del texto según su regex
  simbolos_idioma <- stri_extract_all_regex(texto, expresion_regex_idioma)

  simbolos_idioma <- simbolos_idioma[!sapply(simbolos_idioma, function(x) all(is.na(x)))]
  simbolos_limpios <- na.omit(unlist(simbolos_idioma))

  # Por comodidad los unimos
  resultado <- paste(simbolos_limpios, collapse = " ")

  return(resultado)
}

```


```{r}
texto_regular <- extraer_simbolos(letras_limpias$Lyric,  "[A-Za-z]+")
texto_coreano <- extraer_simbolos(letras_limpias$Lyric,  "[\\uAC00-\\uD7AF]+")
texto_japones_h <- extraer_simbolos(letras_limpias$Lyric,  "[\\u3040-\\u309F]+" )
texto_japones_k <- extraer_simbolos(letras_limpias$Lyric,   "[\\u30A0-\\u30FF]+" )
texto_chino <- extraer_simbolos(letras_limpias$Lyric,   "[\\u4E00-\\u9FFF]+" )

```

Esta línea es por si la forma de traducción utilizada provoca algún error en particular

```{r}
#py_install("googletrans==4.0.0-rc1")
```

Invocamos un chunk de Python puesto que en R las librerias que permiten traducir necesitan un API, así que utilizamos un librería de python para poder traducir cada texto según su idioma con a  lo máximo 15 mil cáracteres por "bloque" de texto.

```{python}
#importamos la libreria
from googletrans import Translator

#Hacemos una función para poder traducir cada texto según su idioma
def traducir_texto(text, target_lang):
    traductor = Translator()
    #Partimos los bloques de texto para poder aprovechar la gratuidad de la libreria
    partes = [text[i:i+15000] for i in range(0, len(text), 15000)]
    partes_traducidas = []
    for parte_trad in partes_traducidas:
        traducido = translator.translate(partes, dest=target_lang).text
        partes_traducidas.append(traducido)
    return ' '.join(parte_trad)
```

```{r}
# "Traducimos" los objetos de R en objetos de Python para poder utilizar la función de traducción
py$texto_coreano <- texto_coreano  
py$texto_japones_h <- texto_japones_h 
py$texto_japones_k <- texto_japones_k 
py$texto_chino <- texto_chino  
```

```{python}
#Traducimos a nuestro idioma deseado
traducido_coreano = translate_text(r.texto_coreano, 'en')
traducido_texto_japones_h = translate_text(r.texto_japones_h, 'en')
traducido_texto_japones_k = translate_text(r.texto_japones_k, 'en')
traducido_chino = translate_text(r.texto_chino, 'en')
```

```{r}
#Regresamos los objetos traducidos de python a objetos de R
traducido_coreano <- py$traducido_coreano
traducido_texto_japones_h <- py$traducido_texto_japones_h
traducido_texto_japones_k <- py$traducido_texto_japones_k
traducido_chino <- py$traducido_chino
```

```{r}
BTS_texto <-c(texto_regular, traducido_coreano, traducido_texto_japones_h, traducido_texto_japones_k, traducido_chino)
```

```{r}
#Generamos la nube de palabras usando el texto traducido.

BTS_texto %>% 
#Utilizamos la librerías quanteda para separar el texto y
#eliminar proposiciones, articulos, números, signos de puntuación en inglés (el idioma de la 
#la mayoría de las canciones)
        tokens() %>% tokens_remove(stopwords("english")) %>% tokens_remove(c("oh","v","m","hoo","yeah")) %>% 
    tokens(remove_separators = TRUE,
                  remove_punct = TRUE,
                  remove_symbols = TRUE,
                  remove_numbers = TRUE)%>%
#hacemos una tabla de frecuencias de las palabras queridas y generamos la nube de palabras
#escogemos parametros que consideramos esteticos de la nube de palabras.
    dfm() %>%
    textplot_wordcloud(min_count = 5,
                     max_words = 500,
                     font = "mono",
                    color =  RColorBrewer::brewer.pal(8, "RdYlGn"),
                     comparison = FALSE)

```

